#+TITLE: macs
#+FILETAGS: core
* Overview
Macros for the macro-programmer.

This is a core library module.

Some of the symbols provided are copied directly from their original
source and annotated appropriately. It is not guaranteed that all
symbols perform exactly as the originals. Read the inline comments if
you're unsure.

- requires :: =sbcl 2.3.7+=

#+begin_src lisp :results replace :exports both
  ;; hg clone https://lab.rwest.io/ellis/macs && cd macs && sbcl
  (asdf:load-asd "macs.asd")
  (ql:quickload :macs)
  (ql:quickload :macs/rt)
  (in-package :macs-user)
  (use-package :macs.rt)
  (mapcar ;; list all symbols
   (lambda (p) (cons p (loop for s being the external-symbols of (find-package p) collect s)))
   '(:macs.readtables :macs.reexport :macs.str :macs.sym :macs.list :macs.cond :macs.fu
     :macs.ana :macs.pan :macs.cli :macs.fs :macs.alien :macs.rt))
#+end_src
#+RESULTS:
#+begin_example
((:MACS.READTABLES READTABLE-ERROR UNREGISTER-READTABLE READER-MACRO-CONFLICT
  ENSURE-READTABLE COPY-NAMED-READTABLE PARSE-BODY DEFREADTABLE
  REGISTER-READTABLE LIST-ALL-NAMED-READTABLES IN-READTABLE RENAME-READTABLE
  NAMED-READTABLE-DESIGNATOR FIND-READTABLE READTABLE-DOES-ALREADY-EXIST
  READTABLE-DOES-NOT-EXIST MAKE-READTABLE READTABLE-NAME MERGE-READTABLES-INTO)
 (:MACS.REEXPORT REEXPORT-FROM REEXPORTS)
 (:MACS.STR UNICODE> UNICODE< STRING-DESIGNATOR GRAPHEMES LINES BIDI-CLASS
  DEFAULT-IGNORABLE-P ALPHABETIC-P DECIMAL-VALUE CHAR-BLOCK LOWERCASE STRIPLN
  SENTENCE-BREAK-CLASS UNICODE-EQUAL STRING-SUFFIX-P SPLIT-STRING DIGIT-VALUE
  CASEFOLD STRING-ENCLOSED-P LINE-BREAK-CLASS NORMALIZED-P UPPERCASE-P
  GRAPHEME-BREAK-CLASS SENTENCES UPPERCASE UNICODE= HEX-DIGIT-P CASED-P
  UNICODE<= MATH-P UNICODE>= TITLECASE WORDS BIDI-MIRRORING-GLYPH
  NORMALIZE-STRING LOWERCASE-P MIRRORED-P CONFUSABLE-P WORD-BREAK-CLASS STRCAT
  WHITESPACE-P)
 (:MACS.SYM MAKE-SLOT-NAME ENSURE-SYMBOL KEYWORDICATE SYMBOLICATE
  PACKAGE-SYMBOLICATE FORMAT-SYMBOL GENSYMIFY* MAKE-KEYWORD MAKE-GENSYM
  WITH-UNIQUE-NAMES WITH-GENSYMS MAKE-GENSYM-LIST)
 (:MACS.LIST PROPER-LIST-P ENSURE-LIST ASSQ MEMQ ENSURE-CAR RECONS
  PROPER-LIST-OF-LENGTH-P SINGLETON-P ENSURE-CONS)
 (:MACS.COND SIMPLE-PROGRAM-ERROR SIMPLE-READER-ERROR INVALID-ARGUMENT-ITEM
  UNKNOWN-ARGUMENT-P INVALID-ARGUMENT SIMPLE-STYLE-WARNING
  UNKNOWN-ARGUMENT-NAME IGNORE-SOME-CONDITIONS MISSING-ARGUMENT-P
  INVALID-ARGUMENT-REASON INVALID-ARGUMENT-P MISSING-ARGUMENT UNKNOWN-ARGUMENT
  UNWIND-PROTECT-CASE CIRCULAR-DEPENDENCY-ITEMS CIRCULAR-DEPENDENCY
  SIMPLE-PARSE-ERROR REQUIRED-ARGUMENT MISSING-ARGUMENT-COMMAND
  UNKNOWN-ARGUMENT-KIND)
 (:MACS.FU METHOD-COMBINATION-LAMBDA-LIST O!-SYMBOL-P BUILD-BATCHER-SN
  FIND-FUNCTION-CALLERS TLIST-EMPTY-P TLIST-ADD-RIGHT SOURCE-LOCATION DLAMBDA
  |#"-reader| FIND-FUNCTION-CALLEES DESTRUCTURING-ECASE
  PARSE-EVAL-WHEN-SITUATIONS FLATTEN |#`-reader| DEFCMD O!-SYMBOL-TO-G!-SYMBOL
  IF-LET* *MACS-READTABLE* CHOOSE WHEN-MATCH DEFUN! TLIST-ADD-LEFT
  PARSE-ORDINARY-LAMBDA-LIST IF-MATCH MKSTR SYMB FUNCTION-TYPE
  MAKE-MACRO-LAMBDA WHO-SPECIALIZES-GENERALLY TLIST-RIGHT
  WHO-SPECIALIZES-DIRECTLY DEFTYPE-LAMBDA-LIST DEFMACRO/G!
  SUBST-MODE-PPCRE-LAMBDA-FORM SEGMENT-READER WHEN-LET* TLIST-REM-LEFT
  MATCH-MODE-PPCRE-LAMBDA-FORM ALLOCATION-INFORMATION PARSE-BODY DEFMACRO! FACT
  SORTF DOLLAR-SYMBOL-P DESTRUCTURING-CCASE G!-SYMBOL-P FUNCTION-LAMBDA-LIST
  WHEN-LET MAKE-TLIST TLIST-UPDATE DESTRUCTURING-CASE |#f-reader| IF-LET
  TLIST-LEFT GROUP ONCE-ONLY)
 (:MACS.ANA ALAMBDA ALET AIF ALET% SELF IT THIS NLET-TAIL AWHEN ACOND)
 (:MACS.PAN PANDORICLET-GET PANDORIC-RECODE WITH-PANDORIC PLAMBDA PANDORICLET
  PANDORIC-EVAL PANDORICLET-SET PANDORIC-HOTPATCH GET-PANDORIC)
 (:MACS.CLI PARSE-CLI-ARGS CLI-CMD MAKE-CLI PRINT-USAGE *CLI-ARGS* MAIN
  HANDLE-UNKNOWN-ARGUMENT *CLI-ARG0* *CLI-GROUP-SEPARATOR* CLI PARSE-ARGS
  CLI-CMDS CLI-USAGE CLI-NAME DEFMAIN PRINT-HELP COMMAND-LINE-ARGS CLI-FLAG-P
  CLI-VERSION HANDLE-MISSING-ARGUMENT MAKE-SHORT-NAME CLI-OPT CLI-HELP
  ,*DEFAULT-CLI-OPTS* HANDLE-INVALID-ARGUMENT CLI-OPTS WITH-CLI-HANDLERS
  WITH-CLI)
 (:MACS.FS)
 (:MACS.ALIEN F24 BOOL-TO-FOREIGN-INT I4 U128 U2 U4 U64 U32
  SANCTIFY-FOR-EXECUTION U3 U24 I64 I32 DEFBYTES I128 I2 F64 F32
  FOREIGN-INT-TO-INTEGER I8 FOREIGN-INT-TO-BOOL I3 I16 U8 I24 U1 F16 U16 F128)
 (:MACS.RT *TEST-DEBUG* DBG! TEST-SUITE-DESIGNATOR MAKE-TEST *TESTING*
  TEST-OBJECT ASSURE-SUITE TEST-RESULTS *TEST-SUITE-LIST* IN-SUITE
  CONTINUE-TESTING LOCKED-TESTS POP-TEST *TEST-DEBUG-TIMESTAMP* DO-TEST
  TEST-FAILS TEST-SUITE EVAL-TEST *CATCH-TEST-ERRORS* TEST-FIXTURE DEFSUITE
  PUSH-TEST DEFTEST ENSURE-SUITE TEST-NAME DO-SUITE CHECK-SUITE-DESIGNATOR
  SUITE-NAME= FIND-TEST COMPILE-TEST TESTS DO-TESTS SUITE-NAME-EQ
  ,*COMPILE-TESTS* *TEST-SUITE* DELETE-TEST GET-TEST-OPT MAKE-SUITE WITH-TEST
  ,*TEST-SUFFIX* TEST TEST-DEBUG-TIMESTAMP-SOURCE WITH-TEST-ENV))
#+end_example
** Resources
  - [[https://alexandria.common-lisp.dev/][alexandria]]
  - [[https://edicl.github.io/cl-ppcre/][cl-ppcre]]
  - [[https://github.com/melisgl/named-readtables][named-readtables]]
  - [[https://github.com/takagi/cl-reexport/tree/master][cl-reexport]]
  - [[https://gigamonkeys.com/book/][PCL]]
  - [[https://letoverlambda.com/][LOL]] ([[https://github.com/thephoeron/let-over-lambda/tree/master][production version]])
  - [[https://sep.turbifycdn.com/ty/cdn/paulgraham/bellanguage.txt?t=1688221954&][Bel]]
  - [[https://wiki.c2.com/?LispMacro][c2 wiki on Lisp Macro]]
  - [[https://gitlab.common-lisp.net/asdf/asdf/][asdf]]
  - [[https://www.sbcl.org/manual/][sbcl manual]]
  - [[https://docs.rs/clap/latest/clap/][clap.rs docs]]
** Goals
- power
** Notes
- /Macros aren't about being needlessly terse/ :: \\
  Some people seem to think that once you hit a certain level of
  macs-ification you're just making your code unreadable to save on
  typing, or for the sake of codegolfing. This is not the case - the
  keypresses you can keep for free, but the /power/ comes from using
  macros to /think smarter/ and /faster/ about your problems.
- /Macros don't increase cognitive overhead/ :: \\
  They isolate it. For authors, the benefit of this is ten-fold. We
  write a complex syntax translation, understand it, and use it in
  our code. We don't use it to decrease code size, /we use it to
  simplify patterns/. It allows us to think in terms of the macro
  and skip a great deal of context switching and processing in our
  brains.
- /Blub macros don't come close to the gold standard/ :: \\
  which is *Unhygienic Lisp Macros*. Hygienic macros are an
  unfortunate inclusion of the Scheme specification.
- /Macros are not functions/ :: \\
  This, I credit to Paul Graham. I was actually just searching
  through the Arc [[http://www.arclanguage.org/tut.txt][tutorial]] for the term 'hygienic' because the
  implementation is in Racket and heard chatter of hygienic macros
  in Arc. I was delighted to find this passage:
  #+begin_quote
  One of the keys to understanding macros is to remember that macro
  calls aren't function calls.  Macro calls look like function calls.
  Macro definitions even look a lot like function definitions.  But
  something fundamentally different is happening.  You're transforming
  code, not evaluating it.  Macros live in the land of the names, not 
  the land of the things they refer to.    
  #+end_quote
- /Being terse has utility/ :: \\
  First a quick anecdote: I heard a story from a buddy about an
  individual who wrote some middleware in an extremely terse
  fashion - single letter symbols, one-liners, minimal comments,
  etc.

  I think it's hard to see a reality where that person isn't just
  trying to make a statement and piss off some people, without
  seeing the code or being familiar with the author - because if
  that's how your audience reacts, you're either doing it wrong, or
  being an ass.

  Stories like these are why I believe so many talented developers
  don't fully accept the dark arts of the terse. A bad experience
  which leaves a bitter taste.

  Another part of me thinks there are some social/psychological
  issues in play. Or alternatively, /developers write code for too
  broad of an audience/. Mainstream education encourages high-level
  code which is /optimized for human-readability/ - which isn't
  something I know for a fact but will be sure to ask around and
  report back. I think we can all agree this is a good thing to
  encourage in the classroom in very broad strokes.

  The problem is that I don't think we're doing a good job of
  teaching students how to break these rules, and why you would want
  to. Everyone seems to have this image of the ideal
  =production-quality-code-base= which is, as it turns out, a hell
  of a lot of work. Documentation to the nines. Descriptions in
  every commit. Whitespace! We are conditioned to associate
  human-readability with quality.

  When you're working with thousands of inexperienced contributors,
  yea put some weight on the ol' human interfaces. Take a team of 5
  experts and try that and now you're just overcharging the
  customer. It gets way more complicated every where in-between.
* Systems
** macs/readtables
*** macs.readtables
Named Readtable support. See the [[https://github.com/melisgl/named-readtables][official named-readtables repo]] for details.
** macs
*** macs
Wrapper package. Rexports =macs.*= including =macs.readtables= and
defines LPNs without the =macs.= prefix.
**** macs-user
A special user-space package where extensions, experiments and
prototype symbols can be defined.
*** macs.reexport
Symbol reexport support. See the [[https://github.com/takagi/cl-reexport/tree/master][cl-reexport repo]].
*** macs.str
String utilities. Re-exports from =sb-unicode=.
*** macs.sym
Symbol utilities.
*** macs.list
List utilities.
*** macs.cond
Various conditions, restarts, errors, and other utilities for
exception handling. See [[https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html][PCL]] for an introduction to conditions and
restarts.
*** macs.fu
The =fu= extension package. Includes macro utility functions from LOL,
alexandria, PCL, PG, custom readers, and a named-readtable called
=*macs-readtable*=.
*** macs.ana
Anaphoric macros.
*** macs.pan
Pandoric macros.
*** macs.cli
This package provides an API for building CLI apps. It is highly
opinionated and loosely derived from [[https://github.com/dnaeon/clingon][clingon]] and uiop.
*** macs.alien
Foreign alien types, utils, and helpers.
** macs/rt
*** macs.rt
regression testing framework.
** macs/tests
*** macs.tests
macs System tests.
