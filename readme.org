#+TITLE: macs
#+FILETAGS: core
* Overview
Macros for the macro-programmer.

This is a core library module.

Some of the symbols provided are copied directly from their original
source and annotated appropriately. It is not guaranteed that all
symbols perform exactly as the originals. Read the inline comments if
you're unsure.

- requires :: =sbcl 2.3.7+=

#+name: macs-collect-symbols
#+begin_src lisp :results output replace :wrap src lisp :exports nil :eval no
  ;; hg clone https://lab.rwest.io/ellis/macs && cd macs && sbcl
  (asdf:load-asd "macs.asd")
  (ql:quickload :macs)
  (ql:quickload :macs/rt)
  (ql:quickload :macs/tests)
  (in-package :macs-user)
  (use-package :macs.rt)
  (use-package :macs.tests)
  (in-readtable *macs-readtable*)
  (defmacro %m nil #`,(keywordicate ':macs. a1))
  (defun %ps () '(readtables reexport str sym list cond fu ana pan cli fs alien rt tests)) 
  (defun ps nil (mapcar (%m) (%ps)))
  (defun %s () #`,(cons a1 (loop for s being the external-symbols of (find-package a1) collect s)))
  (defun s nil (mapcar (%s) (ps)))
  (defmacro p (x) `(cdr (assoc (funcall (%m) ,x) (s))))
#+end_src

#+RESULTS: macs-collect-symbols 
#+begin_src lisp
To load "macs":
  Load 1 ASDF system:
    macs
; Loading "macs"

To load "macs/rt":
  Load 1 ASDF system:
    macs/rt
; Loading "macs/rt"

To load "macs/tests":
  Load 1 ASDF system:
    macs/tests
; Loading "macs/tests"

#+end_src

#+name: p
#+begin_src lisp :package macs-user :results output replace :var pkg='_ :exports nil :eval no :wrap src lisp
  (print (p pkg))
#+end_src

* Systems
** macs/readtables
*** macs.readtables
Named Readtable support. See the [[https://github.com/melisgl/named-readtables][official named-readtables repo]] for details.
#+CALL: p('readtables)
#+RESULTS:
#+begin_src lisp

(READTABLE-ERROR UNREGISTER-READTABLE READER-MACRO-CONFLICT ENSURE-READTABLE
 COPY-NAMED-READTABLE PARSE-BODY DEFREADTABLE REGISTER-READTABLE
 LIST-ALL-NAMED-READTABLES IN-READTABLE RENAME-READTABLE
 NAMED-READTABLE-DESIGNATOR FIND-READTABLE READTABLE-DOES-ALREADY-EXIST
 READTABLE-DOES-NOT-EXIST MAKE-READTABLE READTABLE-NAME MERGE-READTABLES-INTO) 
#+end_src
** macs
*** macs
Wrapper package. Rexports =macs.*= including =macs.readtables=.
**** macs-user
A special user-space package where extensions, experiments and
prototype symbols can be defined.
*** macs.reexport
Symbol reexport support. See the [[https://github.com/takagi/cl-reexport/tree/master][cl-reexport repo]].
#+CALL: p('reexport)
#+RESULTS:
#+begin_src lisp

(REEXPORT-FROM REEXPORTS) 
#+end_src
*** macs.str
String utilities. Re-exports from =sb-unicode=.
#+CALL: p('str)
#+RESULTS:
#+begin_src lisp

(UNICODE> UNICODE< STRING-DESIGNATOR GRAPHEMES LINES BIDI-CLASS
          DEFAULT-IGNORABLE-P ALPHABETIC-P DECIMAL-VALUE CHAR-BLOCK LOWERCASE
          SENTENCE-BREAK-CLASS UNICODE-EQUAL DIGIT-VALUE CASEFOLD
          LINE-BREAK-CLASS NORMALIZED-P UPPERCASE-P GRAPHEME-BREAK-CLASS
          SENTENCES UPPERCASE UNICODE= HEX-DIGIT-P CASED-P UNICODE<= MATH-P
          UNICODE>= TITLECASE WORDS BIDI-MIRRORING-GLYPH NORMALIZE-STRING
          LOWERCASE-P MIRRORED-P CONFUSABLE-P WORD-BREAK-CLASS WHITESPACE-P) 
#+end_src
*** macs.sym
Symbol utilities.
#+CALL: p('sym)
#+RESULTS:
#+begin_src lisp

(MAKE-SLOT-NAME ENSURE-SYMBOL KEYWORDICATE SYMBOLICATE PACKAGE-SYMBOLICATE
                FORMAT-SYMBOL GENSYMIFY* MAKE-KEYWORD MAKE-GENSYM
                WITH-UNIQUE-NAMES WITH-GENSYMS MAKE-GENSYM-LIST) 
#+end_src
*** macs.list
List utilities.
#+CALL: p('list)
#+RESULTS:
#+begin_src lisp

(PROPER-LIST-P ENSURE-LIST ASSQ MEMQ ENSURE-CAR RECONS PROPER-LIST-OF-LENGTH-P
               SINGLETON-P ENSURE-CONS) 
#+end_src
*** macs.cond
Various conditions, restarts, errors, and other utilities for
exception handling. See [[https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html][PCL]] for an introduction to conditions and
restarts.
#+CALL: p('cond)
#+RESULTS:
#+begin_src lisp

(SIMPLE-PROGRAM-ERROR SIMPLE-READER-ERROR INVALID-ARGUMENT-ITEM
                      UNKNOWN-ARGUMENT-P INVALID-ARGUMENT SIMPLE-STYLE-WARNING
                      UNKNOWN-ARGUMENT-NAME IGNORE-SOME-CONDITIONS
                      MISSING-ARGUMENT-P INVALID-ARGUMENT-REASON
                      INVALID-ARGUMENT-P MISSING-ARGUMENT UNKNOWN-ARGUMENT
                      UNWIND-PROTECT-CASE CIRCULAR-DEPENDENCY-ITEMS NYI!
                      CIRCULAR-DEPENDENCY SIMPLE-PARSE-ERROR REQUIRED-ARGUMENT
                      MISSING-ARGUMENT-COMMAND UNKNOWN-ARGUMENT-KIND) 
#+end_src
*** macs.fu
The =fu= extension package. Includes macro utility functions from LOL,
alexandria, PCL, PG, custom readers, and a named-readtable called
=*macs-readtable*=.
#+CALL: p('fu)
#+RESULTS:
#+begin_src lisp

(LIST-INDIRECT-SLOT-METHODS LIST-CLASS-METHODS WHEN-LET* DEFMACRO! CHOOSE
 ONCE-ONLY WHEN-LET SYMB |#f-reader| DESTRUCTURING-CASE
 WHO-SPECIALIZES-GENERALLY SUBST-MODE-PPCRE-LAMBDA-FORM MAKE-MACRO-LAMBDA
 WHEN-MATCH *MACS-READTABLE* PARSE-EVAL-WHEN-SITUATIONS IF-MATCH
 PARSE-LAMBDA-LIST DEFMACRO/G! DEFUN! DLAMBDA FUNCTION-LAMBDA-LIST
 TLIST-REM-LEFT O!-SYMBOL-TO-G!-SYMBOL TLIST-ADD-LEFT SEGMENT-READER
 METHOD-COMBINATION-LAMBDA-LIST LIST-SLOT-VALUES-USING-CLASS MAKE-TLIST DEFCMD
 LIST-CLASS-SLOTS TLIST-ADD-RIGHT O!-SYMBOL-P TLIST-LEFT FIND-FUNCTION-CALLERS
 |#`-reader| SORTF SOURCE-LOCATION BUILD-BATCHER-SN |#"-reader| SORT! MKSTR
 DESTRUCTURING-ECASE DESTRUCTURING-CCASE IF-LET* FACT FIND-FUNCTION-CALLEES
 ALLOCATION-INFORMATION MERGE! MATCH-MODE-PPCRE-LAMBDA-FORM TLIST-UPDATE
 TLIST-EMPTY-P DOLLAR-SYMBOL-P DEFTYPE-LAMBDA-LIST TLIST-RIGHT IF-LET
 FUNCTION-TYPE FLATTEN G!-SYMBOL-P WHO-SPECIALIZES-DIRECTLY GROUP) 
#+end_src
*** macs.ana
Anaphoric macros.
#+CALL: p('ana)
#+RESULTS:
#+begin_src lisp

(ALET NLET-TAIL ACOND2 SELF IT THIS AWHEN AIF ALET% ACOND ALAMBDA) 
#+end_src
*** macs.pan
Pandoric macros.
#+CALL: p('pan)
#+RESULTS:
#+begin_src lisp

(PANDORICLET-GET PANDORIC-RECODE WITH-PANDORIC PLAMBDA PANDORICLET
                 PANDORIC-EVAL PANDORICLET-SET PANDORIC-HOTPATCH GET-PANDORIC) 
#+end_src
*** macs.cli
This package provides an API for building CLI apps. It is highly
opinionated and loosely derived from [[https://github.com/dnaeon/clingon][clingon]] and uiop.

- [2023-09-17 Sun] :: =completing-read= and =make-prompt!= added for
  CLI-based data entry

#+CALL: p('cli)
#+RESULTS:
#+begin_src lisp

(CLI-USAGE CLI-CMDS INIT-ARGS PRINT-USAGE WITH-CLI CLI-CMD PARSE-ARGS
 MAKE-PROMPT! MAKE-OPTS *ARGV* CLI-ARGS PRINT-HELP WITH-CLI-HANDLERS CLI-OPT
 COMPLETING-READ DO-CMD MAKE-SHORTY HANDLE-UNKNOWN-ARGUMENT
 HANDLE-MISSING-ARGUMENT COMMAND-LINE-ARGS CLI-VERSION CLI-NAME
 HANDLE-INVALID-ARGUMENT MAKE-CLI CLI DEFMAIN MAKE-CMDS EXEC-PATH-LIST CLI-OPTS
 PRINT-VERSION CLI-THUNK CLI-ARG0 ARGP *CLI-GROUP-SEPARATOR* MAIN
 CLI-DESCRIPTION) 
#+end_src
*** macs.alien
Foreign alien types, utils, and helpers.
#+CALL: p('alien)
#+RESULTS:
#+begin_src lisp

(F24 BOOL-TO-FOREIGN-INT I4 U128 U2 U4 U64 U32 SANCTIFY-FOR-EXECUTION U3 U24
 I64 I32 DEFBYTES I128 I2 F64 F32 FOREIGN-INT-TO-INTEGER I8 FOREIGN-INT-TO-BOOL
 I3 I16 U8 I24 U1 F16 U16 F128) 
#+end_src
** macs/rt
*** macs.rt
regression testing framework.
#+CALL: p('rt)
#+RESULTS:
#+begin_src lisp

(DO-SUITE TEST-SUITE TEST-NAME= TEST-FAILED DELETE-TEST TEST-SUITE-DESIGNATOR
          IS FIND-TEST TEST-OBJECT PUSH-TEST *CATCH-TEST-ERRORS*
          CONTINUE-TESTING ENSURE-SUITE LOCKED-TESTS TEST-PASS-P *TESTING*
          TEST-FAIL-P WITH-TEST *DEFAULT-TEST-SUITE-NAME*
          CHECK-SUITE-DESIGNATOR WITH-TEST-ENV DO-TESTS *TEST-SUFFIX* FAIL!
          ,*TEST-DEBUG* *COMPILE-TESTS* MAKE-SUITE SIGNALS TEST-RESULTS
          EVAL-TEST MAKE-TEST TEST-NAME COMPILE-TEST DO-TEST *TEST-SUITE-LIST*
          POP-TEST GET-TEST-OPT TESTS DEFSUITE DEFTEST IN-SUITE *TEST-SUITE*
          TEST-FIXTURE TEST-SKIP-P TEST) 
#+end_src
** macs/tests
You can run the tests with asdf:
#+begin_src shell :results output silent :exports both
  sbcl --noinform --eval '(progn (asdf:load-system :macs/tests) (asdf:test-system "macs"))'
#+end_src

Or interactively:
#+begin_src lisp :results output replace :wrap src lisp :exports both :package :macs.tests
  (load "tests.lisp")
  (in-package :macs.tests)
  (setq *log-level* :debug)
  (setq *catch-test-errors* t)
  (setq *compile-tests* t)
  (list (multiple-value-list (do-tests :macs)) (test-results *test-suite*))
#+end_src

#+RESULTS:
#+begin_src lisp
in suite MACS with 15/15 tests:
:DEBUG @ 348.06 :: running test:  #<TEST CLI :fn CLI-test514 :args NIL :persist NIL {1005756343}> 
:DEBUG @ 348.07666 :: #<PASS (EQ (MAKE-SHORTY test) t)> 
:DEBUG @ 348.07666 :: #<PASS (EQUALP (PROC-ARGS CLI '(-f baz --bar fax))
                                     (MAKE-CLI-AST
                                      (LIST (MAKE-CLI-NODE 'OPT f)
                                            (MAKE-CLI-NODE 'CMD baz)
                                            (MAKE-CLI-NODE 'OPT bar)
                                            (MAKE-CLI-NODE 'ARG fax))))> 
:DEBUG @ 348.07666 :: #S(CLI-AST
                         :AST (#S(CLI-NODE :KIND OPT :FORM bar)
                               #S(CLI-NODE :KIND CMD :FORM baz)
                               #S(CLI-NODE :KIND OPT :FORM f)
                               #S(CLI-NODE :KIND ARG :FORM yaks))) 
:DEBUG @ 348.07666 :: #<PASS (PARSE-ARGS CLI '(--bar baz -f yaks))> 
0.1.0
:DEBUG @ 348.07666 :: #<PASS (NULL (PRINT-VERSION CLI))> 
  usage: macs.tests [global] <command> [<arg>]

:DEBUG @ 348.07666 :: #<PASS (NULL (PRINT-USAGE CLI))> 
macs.tests v0.1.0
  usage: macs.tests [global] <command> [<arg>]

  test cli

  options:
     -f/--foo* :  bar
     -b/--bar  :  foo

  commands:
    baz  :  baz
     -f/--foo* :  bar
     -b/--bar  :  foo
:DEBUG @ 348.07666 :: #<PASS (NULL (PRINT-HELP CLI))> 
#<PASS CLI-TEST514> 
:DEBUG @ 348.07666 :: running test:  #<TEST PAN :fn PAN-test513 :args NIL :persist NIL {100563E043}> 
:DEBUG @ 348.08667 :: #<PASS (= 0 (FUNCALL P NIL))> 
:DEBUG @ 348.08667 :: #<PASS (= 1 (FUNCALL P 1))> 
:DEBUG @ 348.08667 :: #<PASS (= 1 B C)> 
#<PASS PAN-TEST513> 
:DEBUG @ 348.08667 :: running test:  #<TEST ANA :fn ANA-test512 :args NIL :persist NIL {100563BB13}> 
:DEBUG @ 348.09 :: #<PASS (= 8 (AIF (+ 2 2) (+ IT IT)))> 
#<PASS ANA-TEST512> 
:DEBUG @ 348.09 :: running test:  #<TEST FU :fn FU-test511 :args NIL :persist NIL {100563A323}> 
#<PASS FU-TEST511> 
:DEBUG @ 348.09 :: running test:  #<TEST FMT :fn FMT-test510 :args NIL :persist NIL {1005638E93}> 
:DEBUG @ 348.09668 :: #<PASS (STRING= (FORMAT NIL | 1 | 2 | 3 |~%)
                                      (FMT-ROW '(1 2 3)))> 
:DEBUG @ 348.09668 :: #<PASS (STRING= (FMT-SXHASH (SXHASH T))
                                      (FMT-SXHASH (SXHASH T)))> 
:DEBUG @ 348.09668 :: #<PASS (STRING=
                              (FMT-TREE NIL '(FOOBAR (A) (B) (C) (D)) LAYOUT
                                        DOWN)
                              FOOBAR
 ├─ :A
 ├─ :B
 ├─  C
 ╰─  D
)> 
:DEBUG @ 348.09668 :: #<PASS (STRING=
                              (FMT-TREE NIL
                                        '(SK-PROJECT NAME foobar PATH
                                          /a/b/c.asd VC HG)
                                        LAYOUT DOWN PLIST T)
                              SK-PROJECT
 ├─ :NAME
 │   ╰─ "foobar"
 ├─ :PATH
 │   ╰─ "/a/b/c.asd"
 ╰─ :VC
     ╰─ :HG
)> 
#<PASS FMT-TEST510> 
:DEBUG @ 348.09668 :: running test:  #<TEST ALIEN :fn ALIEN-test509 :args NIL :persist NIL {1005611B53}> 
:DEBUG @ 348.1 :: #<PASS (= 0 (FOREIGN-INT-TO-INTEGER 0 4))> 
:DEBUG @ 348.1 :: #<PASS (= 1 (BOOL-TO-FOREIGN-INT T))> 
#<PASS ALIEN-TEST509> 
:DEBUG @ 348.1 :: running test:  #<TEST THREAD :fn THREAD-test508 :args NIL :persist NIL {100555EF33}> 
Current thread: #<THREAD tid=1441051 "worker" RUNNING {1004C4CD53}>

Current thread name: worker

All threads:
 #<THREAD tid=1438725 "main thread" RUNNING {1000000113}>
#<THREAD tid=1441051 "worker" RUNNING {1004C4CD53}>
#<THREAD tid=1438752 "reader-thread" RUNNING {1002C30DF3}>
#<THREAD tid=1438759 "repl-thread" RUNNING {10045411B3}>
#<THREAD tid=1438758 "auto-flush-thread" RUNNING {1004540133}>
#<THREAD tid=1438753 "swank-indentation-cache-thread" RUNNING {1002C30FC3}>
#<THREAD tid=1438751 "control-thread" RUNNING {1002C21203}>

#<PASS THREAD-TEST508> 
:DEBUG @ 348.1 :: running test:  #<TEST REEXPORT :fn REEXPORT-test507 :args NIL :persist NIL {100555DC93}> 
#<PASS REEXPORT-TEST507> 
:DEBUG @ 348.1 :: running test:  #<TEST COND :fn COND-test506 :args NIL :persist NIL {100555C9F3}> 
#<PASS COND-TEST506> 
:DEBUG @ 348.1 :: running test:  #<TEST LOG :fn LOG-test505 :args NIL :persist NIL {100555B4C3}> 
:DEBUG @ 348.1 :: test DEBUG 
#<PASS LOG-TEST505> 
:DEBUG @ 348.1 :: running test:  #<TEST LIST :fn LIST-test504 :args NIL :persist NIL {1005559F23}> 
:DEBUG @ 348.10333 :: #<PASS (EQ (ENSURE-CAR '(0)) (ENSURE-CAR 0))> 
:DEBUG @ 348.10333 :: #<PASS (EQ (ENSURE-CAR '(NIL)) (ENSURE-CAR NIL))> 
:DEBUG @ 348.10333 :: #<PASS (NOT (EQ (ENSURE-CONS 0) (ENSURE-CONS 0)))> 
:DEBUG @ 348.10333 :: #<PASS (EQUAL (ENSURE-CONS 0) (ENSURE-CONS 0))> 
#<PASS LIST-TEST504> 
:DEBUG @ 348.10333 :: running test:  #<TEST STR :fn STR-test503 :args NIL :persist NIL {100549FF63}> 
:DEBUG @ 348.10666 :: #<PASS (TYPEP test 'STRING-DESIGNATOR)> 
:DEBUG @ 348.10666 :: #<PASS (TYPEP 'TEST 'STRING-DESIGNATOR)> 
:DEBUG @ 348.10666 :: #<PASS (TYPEP C 'STRING-DESIGNATOR)> 
:DEBUG @ 348.10666 :: #<PASS (NOT (TYPEP 0 'STRING-DESIGNATOR))> 
#<PASS STR-TEST503> 
:DEBUG @ 348.10666 :: running test:  #<TEST SYM :fn SYM-test502 :args NIL :persist NIL {100549E3D3}> 
:DEBUG @ 348.11334 :: #<PASS (NOT (EQUALP (MAKE-GENSYM 'A) (MAKE-GENSYM 'A)))> 
:DEBUG @ 348.11334 :: #<PASS (EQ (ENSURE-SYMBOL 'TESTS MACS.TESTS) 'TESTS)> 
:DEBUG @ 348.11334 :: #<PASS (EQ 'FOO (FORMAT-SYMBOL MACS.TESTS ~A 'FOO))> 
:DEBUG @ 348.11334 :: #<PASS (EQ (MAKE-KEYWORD 'FIZZ) FIZZ)> 
#<PASS SYM-TEST502> 
:DEBUG @ 348.11334 :: running test:  #<TEST READTABLES :fn READTABLES-test501 :args NIL :persist NIL {100549C0F3}> 
:DEBUG @ 348.11334 :: #<PASS (TYPEP (LAMBDA (A1) `(,A1 ,A1 ',A1 ,@A1))
                                    'FUNCTION)> 
#<PASS READTABLES-TEST501> 
:DEBUG @ 348.11334 :: running test:  #<TEST RT :fn RT-test500 :args NIL :persist NIL {100549A903}> 
:DEBUG @ 348.12668 :: #<PASS (TYPEP (MAKE-FIXTURE-PROTOTYPE EMPTY NIL)
                                    'FIXTURE-PROTOTYPE)> 
:DEBUG @ 348.12668 :: #<PASS (TYPEP
                              (MAKE-FIXTURE TFIX
                                  NIL
                                  NIL
                                T)
                              'FUNCTION)> 
:DEBUG @ 348.12668 :: #<PASS (NOT
                              (MEMBER 'NIL
                                      (MAPCAR #'= (LIST 1 2 3) (LIST A B C))))> 
#<PASS RT-TEST500> 
No tests failed.
#+end_src

*** macs.tests
macs System tests.
#+CALL: p('tests)
#+RESULTS:
#+begin_src lisp

(RUN-TESTS) 
#+end_src
* Notes
- /Macros aren't about being needlessly terse/ :: \\
  Some people seem to think that once you hit a certain level of
  macs-ification you're just making your code unreadable to save on
  typing, or for the sake of codegolfing. This is not the case - the
  keypresses you can keep for free, but the /power/ comes from using
  macros to /think smarter/ and /faster/ about your problems.
- /Macros don't increase cognitive overhead/ :: \\
  They isolate it. For authors, the benefit of this is ten-fold. We
  write a complex syntax translation, understand it, and use it in
  our code. We don't use it to decrease code size, /we use it to
  simplify patterns/. It allows us to think in terms of the macro
  and skip a great deal of context switching and processing in our
  brains.
- /Blub macros don't come close to the gold standard/ :: \\
  which is *Unhygienic Lisp Macros*. Hygienic macros are an
  unfortunate inclusion of the Scheme specification.
- /Macros are not functions/ :: \\
  This, I credit to Paul Graham. I was actually just searching
  through the Arc [[http://www.arclanguage.org/tut.txt][tutorial]] for the term 'hygienic' because the
  implementation is in Racket and heard chatter of hygienic macros
  in Arc. I was delighted to find this passage:
  #+begin_quote
  One of the keys to understanding macros is to remember that macro
  calls aren't function calls.  Macro calls look like function calls.
  Macro definitions even look a lot like function definitions.  But
  something fundamentally different is happening.  You're transforming
  code, not evaluating it.  Macros live in the land of the names, not 
  the land of the things they refer to.    
  #+end_quote
- /Being terse has utility/ :: \\
  First a quick anecdote: I heard a story from a buddy about an
  individual who wrote some middleware in an extremely terse
  fashion - single letter symbols, one-liners, minimal comments,
  etc.

  I think it's hard to see a reality where that person isn't just
  trying to make a statement and piss off some people, without
  seeing the code or being familiar with the author - because if
  that's how your audience reacts, you're either doing it wrong, or
  being an ass.

  Stories like these are why I believe so many talented developers
  don't fully accept the dark arts of the terse. A bad experience
  which leaves a bitter taste.

  Another part of me thinks there are some social/psychological
  issues in play. Or alternatively, /developers write code for too
  broad of an audience/. Mainstream education encourages high-level
  code which is /optimized for human-readability/ - which isn't
  something I know for a fact but will be sure to ask around and
  report back. I think we can all agree this is a good thing to
  encourage in the classroom in very broad strokes.

  The problem is that I don't think we're doing a good job of
  teaching students how to break these rules, and why you would want
  to. Everyone seems to have this image of the ideal
  =production-quality-code-base= which is, as it turns out, a hell
  of a lot of work. Documentation to the nines. Descriptions in
  every commit. Whitespace! We are conditioned to associate
  human-readability with quality.

  When you're working with thousands of inexperienced contributors,
  yea put some weight on the ol' human interfaces. Take a team of 5
  experts and try that and now you're just overcharging the
  customer. It gets way more complicated every where in-between.
* Resources
  - [[https://alexandria.common-lisp.dev/][alexandria]]
  - [[https://edicl.github.io/cl-ppcre/][cl-ppcre]]
  - [[https://github.com/melisgl/named-readtables][named-readtables]]
  - [[https://github.com/takagi/cl-reexport/tree/master][cl-reexport]]
  - [[https://gigamonkeys.com/book/][PCL]]
  - [[https://letoverlambda.com/][LOL]] ([[https://github.com/thephoeron/let-over-lambda/tree/master][production version]])
  - [[https://sep.turbifycdn.com/ty/cdn/paulgraham/bellanguage.txt?t=1688221954&][Bel]]
  - [[https://wiki.c2.com/?LispMacro][c2 wiki on Lisp Macro]]
  - [[https://gitlab.common-lisp.net/asdf/asdf/][asdf]]
  - [[https://www.sbcl.org/manual/][sbcl manual]]
  - [[https://docs.rs/clap/latest/clap/][clap.rs docs]]

