#+TITLE: macs
#+FILETAGS: core
* Overview
Macros for the macro-programmer.

This is a core library module.

Some of the symbols provided are copied directly from their original
source and annotated appropriately. It is not guaranteed that all
symbols perform exactly as the originals. Read the inline comments if
you're unsure.

- requires :: =sbcl 2.3.7+=

#+begin_src lisp :results replace :exports both
  ;; hg clone https://lab.rwest.io/ellis/macs && cd macs && sbcl
  (asdf:load-asd "macs.asd")
  (ql:quickload :macs)
  (ql:quickload :macs/rt)
  (in-package :macs-user)
  (use-package :macs.rt)
  (mapcar ;; list all symbols
   (lambda (p) (cons p (loop for s being the external-symbols of (find-package p) collect s)))
   '(:macs.readtables :macs.reexport :macs.str :macs.sym :macs.list :macs.cond :macs.fu
     :macs.ana :macs.pan :macs.cli :macs.fs :macs.alien :macs.rt))
#+end_src
#+RESULTS:
#+begin_example
((:MACS.READTABLES READTABLE-ERROR UNREGISTER-READTABLE READER-MACRO-CONFLICT
  ENSURE-READTABLE COPY-NAMED-READTABLE PARSE-BODY DEFREADTABLE
  REGISTER-READTABLE LIST-ALL-NAMED-READTABLES IN-READTABLE RENAME-READTABLE
  NAMED-READTABLE-DESIGNATOR FIND-READTABLE READTABLE-DOES-ALREADY-EXIST
  READTABLE-DOES-NOT-EXIST MAKE-READTABLE READTABLE-NAME MERGE-READTABLES-INTO)
 (:MACS.REEXPORT REEXPORT-FROM REEXPORTS)
 (:MACS.STR UNICODE> UNICODE< STRING-DESIGNATOR GRAPHEMES LINES BIDI-CLASS
  DEFAULT-IGNORABLE-P ALPHABETIC-P DECIMAL-VALUE CHAR-BLOCK LOWERCASE STRIPLN
  SENTENCE-BREAK-CLASS UNICODE-EQUAL STRING-SUFFIX-P SPLIT-STRING DIGIT-VALUE
  CASEFOLD STRING-ENCLOSED-P LINE-BREAK-CLASS NORMALIZED-P UPPERCASE-P
  GRAPHEME-BREAK-CLASS SENTENCES UPPERCASE UNICODE= HEX-DIGIT-P CASED-P
  UNICODE<= MATH-P UNICODE>= TITLECASE WORDS BIDI-MIRRORING-GLYPH
  NORMALIZE-STRING LOWERCASE-P MIRRORED-P CONFUSABLE-P WORD-BREAK-CLASS STRCAT
  WHITESPACE-P)
 (:MACS.SYM MAKE-SLOT-NAME ENSURE-SYMBOL KEYWORDICATE SYMBOLICATE
  PACKAGE-SYMBOLICATE FORMAT-SYMBOL GENSYMIFY* MAKE-KEYWORD MAKE-GENSYM
  WITH-UNIQUE-NAMES WITH-GENSYMS MAKE-GENSYM-LIST)
 (:MACS.LIST PROPER-LIST-P ENSURE-LIST ASSQ MEMQ ENSURE-CAR RECONS
  PROPER-LIST-OF-LENGTH-P SINGLETON-P ENSURE-CONS)
 (:MACS.COND SIMPLE-PROGRAM-ERROR SIMPLE-READER-ERROR INVALID-ARGUMENT-ITEM
  UNKNOWN-ARGUMENT-P INVALID-ARGUMENT SIMPLE-STYLE-WARNING
  UNKNOWN-ARGUMENT-NAME IGNORE-SOME-CONDITIONS MISSING-ARGUMENT-P
  INVALID-ARGUMENT-REASON INVALID-ARGUMENT-P MISSING-ARGUMENT UNKNOWN-ARGUMENT
  UNWIND-PROTECT-CASE CIRCULAR-DEPENDENCY-ITEMS NYI! CIRCULAR-DEPENDENCY
  SIMPLE-PARSE-ERROR REQUIRED-ARGUMENT MISSING-ARGUMENT-COMMAND
  UNKNOWN-ARGUMENT-KIND)
 (:MACS.FU METHOD-COMBINATION-LAMBDA-LIST O!-SYMBOL-P PARSE-LAMBDA-LIST
  WHO-SPECIALIZES-DIRECTLY FIND-FUNCTION-CALLERS TLIST-EMPTY-P TLIST-ADD-RIGHT
  SOURCE-LOCATION DLAMBDA |#"-reader| FIND-FUNCTION-CALLEES DESTRUCTURING-ECASE
  PARSE-EVAL-WHEN-SITUATIONS FLATTEN |#`-reader| DEFCMD O!-SYMBOL-TO-G!-SYMBOL
  ,*MACS-READTABLE* CHOOSE WHEN-MATCH DEFUN! TLIST-ADD-LEFT IF-LET* IF-MATCH
  MKSTR SYMB FUNCTION-TYPE MAKE-MACRO-LAMBDA WHO-SPECIALIZES-GENERALLY GROUP
  DEFTYPE-LAMBDA-LIST DEFMACRO/G! SUBST-MODE-PPCRE-LAMBDA-FORM SEGMENT-READER
  WHEN-LET* TLIST-REM-LEFT MATCH-MODE-PPCRE-LAMBDA-FORM ALLOCATION-INFORMATION
  DEFMACRO! FACT SORTF DOLLAR-SYMBOL-P DESTRUCTURING-CCASE G!-SYMBOL-P
  FUNCTION-LAMBDA-LIST WHEN-LET BUILD-BATCHER-SN MAKE-TLIST TLIST-UPDATE
  DESTRUCTURING-CASE |#f-reader| IF-LET TLIST-LEFT TLIST-RIGHT ONCE-ONLY)
 (:MACS.ANA ALAMBDA ALET AIF ALET% SELF IT THIS NLET-TAIL AWHEN ACOND)
 (:MACS.PAN PANDORICLET-GET PANDORIC-RECODE WITH-PANDORIC PLAMBDA PANDORICLET
  PANDORIC-EVAL PANDORICLET-SET PANDORIC-HOTPATCH GET-PANDORIC)
 (:MACS.CLI INIT-ARGS ARG-P CLI-USAGE CLI-OPTS CLI-HELP MAKE-CLI
  HANDLE-MISSING-ARGUMENT MAIN CLI-CMDS WITH-CLI *ARGV* MAKE-SHORTY
  HANDLE-UNKNOWN-ARGUMENT CLI-CMD CLI-ARGS HANDLE-INVALID-ARGUMENT
  WITH-CLI-HANDLERS PRINT-HELP *CLI-GROUP-SEPARATOR* CLI-OPT CLI CLI-VERSION
  MAKE-CMDS DEFMAIN CLI-NAME RUN-CMD COMMAND-LINE-ARGS EXEC-PATH-LIST CLI-ARG0
  MAKE-OPTS PARSE-ARGS PRINT-USAGE PRINT-VERSION)
 (:MACS.FS)
 (:MACS.ALIEN F24 BOOL-TO-FOREIGN-INT I4 U128 U2 U4 U64 U32
  SANCTIFY-FOR-EXECUTION U3 U24 I64 I32 DEFBYTES I128 I2 F64 F32
  FOREIGN-INT-TO-INTEGER I8 FOREIGN-INT-TO-BOOL I3 I16 U8 I24 U1 F16 U16 F128)
 (:MACS.RT TEST-DEBUG-TIMESTAMP-SOURCE SUITE-NAME-EQ IN-SUITE WITH-TEST-ENV
  TEST-OBJECT IS TESTS SUITE-NAME= TEST-FIXTURE *DEFAULT-TEST-SUITE-NAME*
  MAKE-TEST *TESTING* FIND-TEST TEST-SUITE *TEST-SUITE* MAKE-SUITE TEST-FAILS
  DO-SUITE DEFTEST PUSH-TEST DEFSUITE TEST-RESULTS SIGNALS *TEST-SUFFIX* TEST
  POP-TEST DO-TESTS TEST-FAILED *COMPILE-TESTS* FAIL! EVAL-TEST
  CHECK-SUITE-DESIGNATOR ENSURE-SUITE LOCKED-TESTS CONTINUE-TESTING
  GET-TEST-OPT WITH-TEST *TEST-SUITE-LIST* TEST-SUITE-DESIGNATOR DO-TEST
  ,*TEST-DEBUG-TIMESTAMP* TEST-NAME *TEST-DEBUG* DELETE-TEST *CATCH-TEST-ERRORS*
  COMPILE-TEST))
#+end_example
** Resources
  - [[https://alexandria.common-lisp.dev/][alexandria]]
  - [[https://edicl.github.io/cl-ppcre/][cl-ppcre]]
  - [[https://github.com/melisgl/named-readtables][named-readtables]]
  - [[https://github.com/takagi/cl-reexport/tree/master][cl-reexport]]
  - [[https://gigamonkeys.com/book/][PCL]]
  - [[https://letoverlambda.com/][LOL]] ([[https://github.com/thephoeron/let-over-lambda/tree/master][production version]])
  - [[https://sep.turbifycdn.com/ty/cdn/paulgraham/bellanguage.txt?t=1688221954&][Bel]]
  - [[https://wiki.c2.com/?LispMacro][c2 wiki on Lisp Macro]]
  - [[https://gitlab.common-lisp.net/asdf/asdf/][asdf]]
  - [[https://www.sbcl.org/manual/][sbcl manual]]
  - [[https://docs.rs/clap/latest/clap/][clap.rs docs]]
** Goals
- power
** Notes
- /Macros aren't about being needlessly terse/ :: \\
  Some people seem to think that once you hit a certain level of
  macs-ification you're just making your code unreadable to save on
  typing, or for the sake of codegolfing. This is not the case - the
  keypresses you can keep for free, but the /power/ comes from using
  macros to /think smarter/ and /faster/ about your problems.
- /Macros don't increase cognitive overhead/ :: \\
  They isolate it. For authors, the benefit of this is ten-fold. We
  write a complex syntax translation, understand it, and use it in
  our code. We don't use it to decrease code size, /we use it to
  simplify patterns/. It allows us to think in terms of the macro
  and skip a great deal of context switching and processing in our
  brains.
- /Blub macros don't come close to the gold standard/ :: \\
  which is *Unhygienic Lisp Macros*. Hygienic macros are an
  unfortunate inclusion of the Scheme specification.
- /Macros are not functions/ :: \\
  This, I credit to Paul Graham. I was actually just searching
  through the Arc [[http://www.arclanguage.org/tut.txt][tutorial]] for the term 'hygienic' because the
  implementation is in Racket and heard chatter of hygienic macros
  in Arc. I was delighted to find this passage:
  #+begin_quote
  One of the keys to understanding macros is to remember that macro
  calls aren't function calls.  Macro calls look like function calls.
  Macro definitions even look a lot like function definitions.  But
  something fundamentally different is happening.  You're transforming
  code, not evaluating it.  Macros live in the land of the names, not 
  the land of the things they refer to.    
  #+end_quote
- /Being terse has utility/ :: \\
  First a quick anecdote: I heard a story from a buddy about an
  individual who wrote some middleware in an extremely terse
  fashion - single letter symbols, one-liners, minimal comments,
  etc.

  I think it's hard to see a reality where that person isn't just
  trying to make a statement and piss off some people, without
  seeing the code or being familiar with the author - because if
  that's how your audience reacts, you're either doing it wrong, or
  being an ass.

  Stories like these are why I believe so many talented developers
  don't fully accept the dark arts of the terse. A bad experience
  which leaves a bitter taste.

  Another part of me thinks there are some social/psychological
  issues in play. Or alternatively, /developers write code for too
  broad of an audience/. Mainstream education encourages high-level
  code which is /optimized for human-readability/ - which isn't
  something I know for a fact but will be sure to ask around and
  report back. I think we can all agree this is a good thing to
  encourage in the classroom in very broad strokes.

  The problem is that I don't think we're doing a good job of
  teaching students how to break these rules, and why you would want
  to. Everyone seems to have this image of the ideal
  =production-quality-code-base= which is, as it turns out, a hell
  of a lot of work. Documentation to the nines. Descriptions in
  every commit. Whitespace! We are conditioned to associate
  human-readability with quality.

  When you're working with thousands of inexperienced contributors,
  yea put some weight on the ol' human interfaces. Take a team of 5
  experts and try that and now you're just overcharging the
  customer. It gets way more complicated every where in-between.
* Systems
** macs/readtables
*** macs.readtables
Named Readtable support. See the [[https://github.com/melisgl/named-readtables][official named-readtables repo]] for details.
** macs
*** macs
Wrapper package. Rexports =macs.*= including =macs.readtables=.
**** macs-user
A special user-space package where extensions, experiments and
prototype symbols can be defined.
*** macs.reexport
Symbol reexport support. See the [[https://github.com/takagi/cl-reexport/tree/master][cl-reexport repo]].
*** macs.str
String utilities. Re-exports from =sb-unicode=.
*** macs.sym
Symbol utilities.
*** macs.list
List utilities.
*** macs.cond
Various conditions, restarts, errors, and other utilities for
exception handling. See [[https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html][PCL]] for an introduction to conditions and
restarts.
*** macs.fu
The =fu= extension package. Includes macro utility functions from LOL,
alexandria, PCL, PG, custom readers, and a named-readtable called
=*macs-readtable*=.
*** macs.ana
Anaphoric macros.
*** macs.pan
Pandoric macros.
*** macs.cli
This package provides an API for building CLI apps. It is highly
opinionated and loosely derived from [[https://github.com/dnaeon/clingon][clingon]] and uiop.
*** macs.alien
Foreign alien types, utils, and helpers.
** macs/rt
*** macs.rt
regression testing framework.
** macs/tests
*** macs.tests
macs System tests.
